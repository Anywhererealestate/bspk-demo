/**
 * $ vite-node .scripts/create-meta.tsx
 *
 * This script generates the tsx file which contains the component definitions data and hooks data scraped from JSdoc
 * comments.
 */
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

import { componentsMeta, typesMeta, utilitiesMeta } from '@bspk/ui/meta';
import React from 'react';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';

import packageJson from '../package.json';
import { routes } from '../src/routes.tsx';
import { kebabCase } from '../src/utils/kebabCase.ts';

function searchIndex(uiVersion: string) {
    // hacky way to get around the fact that we're running in node
    globalThis.window = { location: { hash: '' } } as any;
    globalThis.document = {
        querySelector: () => null,
        querySelectorAll: () => [],
        createElement: () => null,
        location: { hash: '' },
    } as any;

    const entityMap = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#x2F;': '/',
        '&#x27;': "'",
    };

    const index: { title?: string; content?: string; url?: string; kind: string }[] = [];

    index.push(
        ...routes.flatMap((route) => {
            if ('noIndex' in route && route.noIndex) return [];

            if ('Component' in route && route.Component) {
                const { Component } = route;

                const html = renderToString(
                    <StaticRouter location={route.path!}>
                        <Component />
                    </StaticRouter>,
                );

                return {
                    title: route.title,
                    content: processHtml(html),
                    url: route.path,
                    kind: 'Page',
                };
            }

            return [];
        }),
    );

    index.push(
        ...componentsMeta.flatMap((component) => {
            let content = component.description;

            const typeMeta = typesMeta.find((tm) => {
                return tm.name === `${component.name}Props`;
            });

            typeMeta?.properties?.forEach((prop) => {
                content += ` ${prop.name} ${prop.description} ${prop.default}`;
            });

            typeMeta?.references?.forEach((ref) => {
                const refMeta = typesMeta.find((tm) => {
                    return tm.name === ref;
                });

                refMeta?.properties?.forEach((prop) => {
                    content += ` ${prop.name} ${prop.description} ${prop.default}`;
                });
            });

            return {
                title: component.name,
                content,
                url: `/${component.slug}`,
                kind: 'Component',
            };
        }),
    );

    index.push(
        ...utilitiesMeta
            .filter((u) => u.name.startsWith('use'))
            .flatMap((utility) => {
                return {
                    title: utility.name,
                    content: utility.description,
                    url: `/hooks#${kebabCase(utility.name)}`,
                    kind: 'Hook',
                };
            }),
    );

    const filePath = 'src/search-index.ts';

    fs.writeFileSync(
        filePath,
        [
            `/** This file is generated by the ./scripts/create-meta.tsx script. This file contains data scraped from the @bspk/ui package. */`,

            `export const VERSION = '${uiVersion}' as const;`,

            `export const searchIndex = ${JSON.stringify(index, null, 2)} as const`,
        ].join('\n\n'),
    ); // Pretty format JSON

    execSync(`npx prettier --write "${filePath}"`, { stdio: 'inherit' });

    console.info('Search index complete.');

    function processHtml(html: string) {
        return html
            .replace(/&[#\w]+;/g, (s) => entityMap[s] || s)
            .replace(/\n/g, ' ')
            .replace(/<pre.*?<\/pre>/g, ' ')
            .replace(/<style.*?<\/style>/g, ' ')
            .replace(/<[^>]*>/g, ' ')
            .replace(/\s+/g, ' ')
            .replace(/Properties Name Description Default Controls/g, ' ')
            .replace(/Design Review Example Code/g, ' ')
            .replace(/Backlog Example Code/g, ' ')
            .replace(/Work in Progress Example Code/g, ' ')
            .replace(/\s+/g, ' ');
    }
}

function copyDocumentation(rootPath: string) {
    fs.readdirSync(rootPath).forEach((file) => {
        if (file.endsWith('.md')) {
            fs.copyFileSync(`${rootPath}/${file}`, `./src/docs/${file}`);
        }
    });
}

function copyBspkFilesForTests(rootPath: string) {
    [
        //
        'meta.ts',
        'index.ts',
    ].forEach((sourceFile) => {
        fs.mkdirSync(path.resolve(`./tests/bspk-ui`), { recursive: true });
        fs.copyFileSync(path.resolve(`${rootPath}/${sourceFile}`), path.resolve(`./tests/bspk-ui/${sourceFile}`));
    });
}

async function main() {
    const dependency = packageJson?.dependencies?.['@bspk/ui'];

    let rootPath = path.resolve('./node_modules/@bspk/ui');

    if (dependency?.startsWith('file:')) {
        execSync('cd ../bspk-ui && npm run meta', { stdio: 'inherit' });
        rootPath = path.resolve(dependency.slice(5), '..');
    }

    const uiPackage = JSON.parse(fs.readFileSync(`${rootPath}/package.json`, { encoding: 'utf-8' }));

    searchIndex(uiPackage.version);

    copyDocumentation(rootPath);

    copyBspkFilesForTests(rootPath);

    process.exit(0);
}

main();

/** Copyright 2025 Anywhere Real Estate - CC BY 4.0 */
